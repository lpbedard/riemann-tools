#!/usr/bin/env ruby

require File.expand_path('../../lib/riemann/tools', __FILE__)

class Riemann::Tools::Elasticsearch
  include Riemann::Tools

  require 'faraday'
  require 'json'
  require 'uri'

  opt :read_timeout, 'Faraday read timeout', type: :int, default: 2
  opt :open_timeout, 'Faraday open timeout', type: :int, default: 1
  opt :path_prefix, 'Elasticsearch path prefix for proxied installations e.g. "els" for target http://localhost/els/_cluster/health', default: "/"
  opt :es_host, 'Elasticsearch host', default: "localhost"
  opt :es_port, 'Elasticsearch port', type: :int, default: 9200
  opt :es_wait_for_status, 'ES cluster health status to wait for', default: "yellow"
  opt :es_timeout, 'ES cluster health wait time to get status', default: "60s"

  # Handles HTTP connections and GET requests safely
  def safe_get(uri)
      # Handle connection timeouts
      response = nil
      begin
        connection = Faraday.new(uri)
        response = connection.get do |req|
          req.options[:timeout] = options[:read_timeout]
          req.options[:open_timeout] = options[:open_timeout]
        end
      rescue => e
        report(:host => uri.host,
          :service => "elasticsearch health",
          :state => "critical",
          :description => "HTTP connection error: #{e.class} - #{e.message}"
        )
      end
      response
  end

  def health_url
    path_prefix = options[:path_prefix]
    path_prefix[0] = '' if path_prefix[0]=='/'
    path_prefix[path_prefix.length-1] = '' if path_prefix[path_prefix.length-1]=='/'
    "http://#{options[:es_host]}:#{options[:es_port]}#{path_prefix.length>0?'/':''}#{path_prefix}/_cluster/health?wait_for_status=#{options[:es_wait_for_status]}&timeout=#{options[:es_timeout]}"
  end

  def indices_health_url
    path_prefix = options[:path_prefix]
    path_prefix[0] = '' if path_prefix[0]=='/'
    path_prefix[path_prefix.length-1] = '' if path_prefix[path_prefix.length-1]=='/'
    "http://#{options[:es_host]}:#{options[:es_port]}#{path_prefix.length>0?'/':''}#{path_prefix}/_cat/indices?v"
  end

  def tick
    uri = URI(health_url)
    response = safe_get(uri)

    return if response.nil?

    if response.status != 200
        report(:host => uri.host,
          :service => "elasticsearch health",
          :state => "critical",
          :description => "HTTP connection error: #{response.status} - #{response.body}"
        )
    else
      # Assuming that a 200 will give json
      json = JSON.parse(response.body)
      cluster_name = json.delete("cluster_name")
      cluster_status = json.delete("status")
      state = case cluster_status
      when "green"
        "ok"
      when "yellow"
        "warning"
      when "red"
        "critical"
      end

      indices_status = "\n"
      if cluster_status != "green"
        uri = URI(indices_health_url)
        response = safe_get(uri)
        if (!response.nil? && response.status == 200)
          response.body.each_line { |s|
            if (indices_status.chomp.empty? || /^(red|yellow)/ =~ s)
              indices_status << s
            end
          }
        end
      end

      report(:host => uri.host,
             :service => "elasticsearch health",
             :state => state,
             :description => "Elasticsearch cluster: #{cluster_name} - #{cluster_status} - #{indices_status}")

      json.each_pair do |k,v|
        report(:host => uri.host,
               :service => "elasticsearch #{k}",
               :metric => v,
               :description => "Elasticsearch cluster #{k}"
        )

      end
    end
  end



end
Riemann::Tools::Elasticsearch.run
